import React from "react";
import {
    IDialogContentProps,
    DialogType,
    IButtonStyles,
    Stack,
    StackItem,
    Label,
    PrimaryButton,
    DefaultButton,
    Dialog,
    DialogFooter,
    initializeIcons,
    ThemeProvider,
    createTheme,
    Theme,
    IPalette,
} from "@fluentui/react";
import { AsyncTrunk } from "mobx-sync";
import { configure } from "mobx";
import { observer } from "mobx-react-lite";

import * as PacketLoaderController from "./PacketLoaderController";
import { StateProvider } from "../contexts/StateContext";
import { AppState } from "../state/AppState";
import { GameViewer } from "./GameViewer";
import { ModalDialogContainer } from "./ModalDialogContainer";
import { IGameFormat } from "../state/IGameFormat";
import { IPacket } from "../state/IPacket";
import { IPlayer, Player } from "../state/TeamState";
import { Bonus, ITossupWord, PacketState, Tossup } from "../state/PacketState";
import { ICustomExport } from "../state/CustomExport";
import { Cycle } from "../state/Cycle";
import { ModalVisibilityStatus } from "../state/ModalVisibilityStatus";

// Initialize Fluent UI icons when this is loaded, before the first render
initializeIcons();

// We may want to make this customizable, but for now set it to 5 days
const minAgeToPromptForReset = 5 * 1000 * 60 * 60 * 24; // 5 days in ms

const lightModePalette: Partial<IPalette> = {
    themePrimary: "#0078d4",
    themeLighterAlt: "#eff6fc",
    themeLighter: "#deecf9",
    themeLight: "#c7e0f4",
    themeTertiary: "#71afe5",
    themeSecondary: "#2b88d8",
    themeDarkAlt: "#106ebe",
    themeDark: "#005a9e",
    themeDarker: "#004578",
    neutralLighterAlt: "#faf9f8",
    neutralLighter: "#f3f2f1",
    neutralLight: "#edebe9",
    neutralQuaternaryAlt: "#e1dfdd",
    neutralQuaternary: "#d0d0d0",
    neutralTertiaryAlt: "#c8c6c4",
    neutralTertiary: "#a19f9d",
    neutralSecondary: "#605e5c",
    neutralSecondaryAlt: "#8a8886",
    neutralPrimaryAlt: "#3b3a39",
    neutralPrimary: "#323130",
    neutralDark: "#201f1e",
    black: "#000000",
    white: "#ffffff",
};

// Generated by going to https://fluentuipr.z22.web.core.windows.net/heads/master/theming-designer/index.html
// and using the inverse for each of the three main colors. This looks better than swapping black/white values for
// lightModePalette
const darkModePalette: Partial<IPalette> = {
    themePrimary: "#0078d4",
    themeLighterAlt: "#000508",
    themeLighter: "#001322",
    themeLight: "#00243f",
    themeTertiary: "#00487f",
    themeSecondary: "#006aba",
    themeDarkAlt: "#1684d8",
    themeDark: "#3595de",
    themeDarker: "#66afe7",
    neutralLighterAlt: "#0b0b0b",
    neutralLighter: "#151515",
    neutralLight: "#252525",
    neutralQuaternaryAlt: "#2f2f2f",
    neutralQuaternary: "#373737",
    neutralTertiaryAlt: "#595959",
    neutralTertiary: "#f3f3f3",
    neutralSecondary: "#f5f5f5",
    neutralSecondaryAlt: "#757779", // This is going to be the inverse of light's neutralSecondaryAlt, so there's some distinguishment between neutral secondary
    neutralPrimaryAlt: "#f7f7f7",
    neutralPrimary: "#eeeeee",
    neutralDark: "#fbfbfb",
    black: "#fdfdfd",
    white: "#000000",
};

export const ModaqControl = observer(function ModaqControl(props: IModaqControlProps): JSX.Element {
    const [appState]: [AppState, React.Dispatch<React.SetStateAction<AppState>>] = React.useState(AppState.instance);

    // We only want to run this effect once, which requires passing in an empty array of dependencies
    // eslint-disable-next-line react-hooks/exhaustive-deps
    React.useEffect(() => initializeControl(appState, { ...props, persistState: props.persistState ?? true }), []);

    React.useEffect(() => update(appState, props), [appState, props]);
    React.useEffect(() => {
        if (props.gameFormat != undefined) {
            appState.game.setGameFormat(props.gameFormat);
        }
    }, [appState, props.gameFormat]);
    React.useEffect(() => {
        if (props.packet != undefined) {
            const packet: PacketState | undefined = PacketLoaderController.loadPacket(props.packet);
            if (packet) {
                appState.game.loadPacket(packet);
            }
        }
    }, [appState, props.packet]);
    React.useEffect(() => {
        if (props.players != undefined) {
            appState.game.setPlayers(
                props.players
                    .filter((player) => player != undefined)
                    .map((player) => new Player(player.name, player.teamName, player.isStarter))
            );
        }
    }, [appState, props.players]);

    const theme: Theme = React.useMemo(
        () =>
            createTheme({
                // isInverted doesn't seem to work for creating a dark mode, so use a specific theme that is close enough
                palette: appState.uiState.useDarkMode ? darkModePalette : lightModePalette,
            }),
        [appState.uiState.useDarkMode]
    );

    const applyTo = props.applyStylingToRoot ? "body" : "element";

    return (
        <ErrorBoundary appState={appState}>
            <StateProvider appState={appState}>
                <ThemeProvider theme={theme} applyTo={applyTo}>
                    <div className="modaq-control">
                        <GameViewer />
                        <ModalDialogContainer />
                    </div>
                </ThemeProvider>
            </StateProvider>
        </ErrorBoundary>
    );
});

// We can't use observables here since the user could pass in different instances of IModaqControlProps
// TODO: Should take a callback and settings for export (which ones are enabled, any new export options with a callback
// of game state/QBJ file?)
export interface IModaqControlProps {
    /**
     * If `true`, applies theming to the body, so the background in dark mode will be black evne outside of MODAQ
     */
    applyStylingToRoot?: boolean;

    /**
     * The version that appears when clicking on Help.
     */
    buildVersion?: string;

    /**
     * If defined, this adds another way for game results to get exported. The provided callback will be given the game
     * at the time of export.
     */
    customExport?: ICustomExport;

    /**
     * The format of the current game, such as if powers are supported, if tossups are paired with bonuses, etc.
     */
    gameFormat?: IGameFormat;

    /**
     * Needed if you want to support exporting to Google Sheets. This is the client ID of your Google application that
     * connects to the spreadsheet.
     */
    googleClientId?: string;

    /**
     * When `true`, the New Game button in the menu is hidden.
     */
    hideNewGame?: boolean;

    /**
     * The packet for the current game. This should only be set once.
     */
    packet?: IPacket;

    /**
     * The name of the packet.
     */
    packetName?: string;

    /**
     * The players in the current game. This should only be set once.
     */
    players?: IPlayer[];

    /**
     * Determines if this control should save state locally so that the same packet, players, and cycle appear when the
     * page is refreshed. This can only be set on the first render.
     */
    persistState?: boolean;

    /**
     * If `persistState` is true, then this is the name of the store in localStorge. This can only be set on the first
     * render.
     */
    storeName?: string | undefined;

    /**
     * The URL to a Yet Another Packet Parser (YAPP) compatible service, which parses docx files. If this value isn't
     * defined, then packets must be in a JSON format.
     */
    yappServiceUrl?: string;
}

function initializeControl(appState: AppState, props: IModaqControlProps): () => void {
    if (props.persistState) {
        configure({ enforceActions: "observed", computedRequiresReaction: true });
        const trunk = new AsyncTrunk(appState, { storage: localStorage, storageKey: props.storeName, delay: 200 });
        trunk.init(appState).then(() => {
            // Need to check if game is old and prompt the user if they want to restart the game.
            // Date subtraction gives you the number of milliseconds
            const lastUpdate: number | undefined = appState.game.lastUpdate?.getTime();
            if (lastUpdate && Date.now() - lastUpdate > minAgeToPromptForReset) {
                appState.uiState.dialogState.showOKCancelMessageDialog(
                    "Start new game?",
                    "The loaded game is over 5 days old. Do you want to start a new game instead?",
                    () => {
                        appState.uiState.createPendingNewGame();
                        appState.uiState.dialogState.showNewGameDialog();
                    }
                );
            }
        });
    }

    // We have to add the listener at the document layer, otherwise the event isn't picked up if the user clicks on
    // the empty space
    const keydownListener: (event: KeyboardEvent) => void = (event: KeyboardEvent) => shortcutHandler(event, appState);
    document.addEventListener("keyup", keydownListener);

    return () => {
        document.removeEventListener("keyup", keydownListener);
    };
}

function shortcutHandler(event: KeyboardEvent, appState: AppState): void {
    // Disable shortcuts if there's a modal dialog open
    if (appState.uiState.dialogState.visibleDialog !== ModalVisibilityStatus.None) {
        return;
    }

    switch (event.key.toUpperCase()) {
        case "E":
            // Go to the end of a tossup and open up the buzz menu.
            const tossup: Tossup | undefined = appState.game.getTossup(appState.uiState.cycleIndex);
            if (tossup) {
                // Issue is that this removes parens, so we don't have all the info we need
                const words: ITossupWord[] = tossup.getWords(appState.game.gameFormat);
                const index: number = words.filter((word) => word.canBuzzOn).length - 1;

                appState.uiState.setSelectedWordIndex(index);
                appState.uiState.showBuzzMenu(/* clearSelectedWordOnClose */ false);

                // An alternate approach, if we want to keep keyboard focus there. For now users would probably just
                // keep pressing E, and this way looks uglier (flash of focus, keeps focus after the buzzer is selected)
                // This requires adding the class "word" to the span in QuestionWord.tsx
                // // const index: number = words.length - 1;
                // // const wordElement = document.getElementsByClassName("word").item(index) as HTMLSpanElement;
                // // if (wordElement) {
                // //     wordElement.focus();
                // //     wordElement.click();
                // // }
            }

            event.preventDefault();
            event.stopPropagation();

            break;

        case "N":
            if (appState.uiState.cycleIndex + 1 < appState.game.playableCycles.length) {
                appState.uiState.nextCycle();
            }
            event.preventDefault();
            event.stopPropagation();

            break;

        case "P":
        case "B":
            appState.uiState.previousCycle();
            event.preventDefault();
            event.stopPropagation();
            break;

        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
            // This shortcut is only supported when bouncebacks are disabled. We could add support for it later and just
            // toggle through all the fields, but the logic is slightly more complicated and very few formats use
            // bouncebacks.
            if (appState.game.gameFormat.bonusesBounceBack) {
                event.preventDefault();
                event.stopPropagation();

                return;
            }

            // If there are bonuses and they are active, toggle the bonus part. We have to do some defensive checks to
            // make sure that we can update the bonus
            const cycleIndex: number = appState.uiState.cycleIndex;
            const cycle: Cycle = appState.game.cycles[cycleIndex];
            const bonus: Bonus | undefined = appState.game.getBonus(cycleIndex);
            if (cycle.correctBuzz == undefined || bonus == undefined) {
                event.preventDefault();
                event.stopPropagation();

                return;
            }

            // We know event.key is a number here, so we don't need to check for NaN
            const partIndex: number = Number(event.key) - 1;
            if (bonus.parts.length <= partIndex) {
                event.preventDefault();
                event.stopPropagation();

                return;
            }

            const teamName: string = cycle.correctBuzz.marker.player.teamName;
            const currentPoints: number | undefined = cycle.bonusAnswer?.parts[partIndex].points ?? 0;

            cycle.setBonusPartAnswer(partIndex, teamName, currentPoints > 0 ? 0 : bonus.parts[partIndex].value);

            event.preventDefault();
            event.stopPropagation();
            break;
        default:
            break;
    }
}

function update(appState: AppState, props: IModaqControlProps): void {
    if (props.buildVersion !== appState.uiState.buildVersion) {
        appState.uiState.setBuildVersion(props.buildVersion);
    }

    if (props.googleClientId !== appState.uiState.sheetsState.clientId) {
        appState.uiState.sheetsState.setClientId(props.googleClientId);
    }

    if (props.yappServiceUrl !== appState.uiState.yappServiceUrl) {
        appState.uiState.setYappServiceUrl(props.yappServiceUrl);
    }

    if (props.gameFormat != undefined && props.gameFormat !== appState.game.gameFormat) {
        appState.game.setGameFormat(props.gameFormat);
    }

    if (props.customExport != appState.uiState.customExportOptions) {
        if (props.customExport == undefined) {
            appState.uiState.resetCustomExport();
            appState.setCustomExportInterval(undefined);
        } else {
            const updateInterval: boolean =
                props.customExport.customExportInterval !== appState.uiState.customExportOptions?.customExportInterval;

            appState.uiState.setCustomExport(props.customExport);
            if (updateInterval) {
                appState.setCustomExportInterval(props.customExport.customExportInterval);
            }
        }
    }

    if (props.hideNewGame !== appState.uiState.hideNewGame) {
        appState.uiState.setHideNewGame(props.hideNewGame == true);
    }

    if (props.packetName !== appState.uiState.packetFilename) {
        if (props.packetName != undefined) {
            appState.uiState.setPacketFilename(props.packetName);
        } else {
            appState.uiState.resetPacketFilename();
        }
    }
}

interface IErrorBoundaryProps {
    appState: AppState;
}

interface IErrorBoundaryState {
    error: Error | string | undefined;
    showClearPrompt: boolean;
}

class ErrorBoundary extends React.Component<IErrorBoundaryProps, IErrorBoundaryState> {
    private static readonly dialogContent: IDialogContentProps = {
        type: DialogType.normal,
        title: "Reset",
        closeButtonAriaLabel: "Close",
        subText: "Do you wish to reset the reader? You will lose your current game.",
    };

    private static readonly exportButtonStyle: IButtonStyles = {
        root: {
            marginRight: 20,
            marginTop: 20,
        },
    };

    constructor(props: IErrorBoundaryProps) {
        super(props);

        this.state = { error: undefined, showClearPrompt: false };
    }

    static getDerivedStateFromError(error: Error | string): IErrorBoundaryState {
        // Update state so the next render will show the fallback UI.
        return { error, showClearPrompt: false };
    }

    // // componentDidCatch(error, errorInfo) {
    // //     // You can also log the error to an error reporting service. We don't have a logging service for this
    // // }

    public render() {
        if (this.state.error) {
            const text: string = "Error: " + this.state.error;

            // This shouldn't re-render often, and the user should leave the page soon when this appears, so skip
            // memoization
            const onClear = (): void => {
                const trunk = new AsyncTrunk(this.props.appState, { storage: localStorage, delay: 100 });
                trunk.clear();
                location.reload();
            };

            const hideDialog = (): void => {
                this.setState({ showClearPrompt: false });
            };

            const showDialog = (): void => {
                this.setState({ showClearPrompt: true });
            };

            const gameJson: Blob = new Blob([JSON.stringify(this.props.appState.game)], {
                type: "application/json",
            });
            const url = URL.createObjectURL(gameJson);

            return (
                <Stack>
                    <StackItem>
                        <h2>Something went wrong</h2>
                    </StackItem>
                    <StackItem>
                        <Label>{text}</Label>
                    </StackItem>
                    <StackItem>
                        <Label>
                            Refreshing the page fixes most errors. If you keep seeing errors, click on the first button
                            to copy the JSON of all the events, then click on the second button to reset the app.
                        </Label>
                    </StackItem>
                    <StackItem>
                        <PrimaryButton
                            aria-label="Export game (JSON)"
                            text="Export game (JSON)"
                            styles={ErrorBoundary.exportButtonStyle}
                            href={url}
                            download="QuizBowlReader_Game_Error.json"
                        />
                        <DefaultButton onClick={showDialog} text="Reset" />
                    </StackItem>
                    <Dialog
                        hidden={!this.state.showClearPrompt}
                        onDismiss={hideDialog}
                        dialogContentProps={ErrorBoundary.dialogContent}
                    >
                        <DialogFooter>
                            <PrimaryButton onClick={onClear} text="OK" />
                            <DefaultButton onClick={hideDialog} text="Cancel" />
                        </DialogFooter>
                    </Dialog>
                </Stack>
            );
        }

        return this.props.children;
    }
}

export default ModaqControl;
